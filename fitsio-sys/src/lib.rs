//! This package was automatically generated with [`rust-bindgen`][1] and as such was not
//! user-generated.
//!
//! The functions contained are expected to be used with [`fitsio`][2], a high level API wrapper
//! around the low level direct C-bindings, though the bindings are complete enough to be usable.
//!
//! This code will not be directly documented, and so users should refer to the [`fitsio` C
//! documentation][3] for usage.
//!
//! ## Note about function names
//!
//! Unfortunately we must use fits short names throughout. The C-api exposes long names for
//! functions which are more descriptive, for example `fits_open_file` instead of `ffopen`, but the
//! symbols available in the library have only short names, and the long names are merely
//! preprocessor definitions.
//!
//! ## Examples
//!
//! ```rust
//! # extern crate fitsio_sys;
//! use std::ptr;
//! use std::ffi;
//! # use fitsio_sys::{ffinit, ffphps, ffclos};
//!
//! # fn main() {
//! let filename = ffi::CString::new("!/tmp/test.fits").unwrap();
//! let mut fptr = ptr::null_mut();
//! let mut status = 0;
//!
//! unsafe {
//!     // Create a new file, clobbering any pre-existing file
//!     ffinit(&mut fptr as *mut *mut _,
//!         filename.as_ptr(),
//!         &mut status);
//!
//!     // Add an empty primary HDU
//!     ffphps(fptr, 8, 0, ptr::null_mut(), &mut status);
//!
//!     // Finally close the file
//!     ffclos(fptr, &mut status);
//! }
//!
//! assert_eq!(status, 0);
//! # }
//! ```
//!
//! [1]: https://github.com/crabtw/rust-bindgen
//! [2]: https://crates.io/crates/fitsio
//! [3]: http://heasarc.gsfc.nasa.gov/docs/software/fitsio/c/c_user/cfitsio.html

// automatically generated by rust-bindgen
#![allow(dead_code, non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

use self::libc::*;

pub type LONGLONG = c_longlong;

#[repr(C)]
#[derive(Copy)]
pub struct tcolumn {
    pub ttype: [c_char; 70usize],
    pub tbcol: LONGLONG,
    pub tdatatype: c_int,
    pub trepeat: LONGLONG,
    pub tscale: c_double,
    pub tzero: c_double,
    pub tnull: LONGLONG,
    pub strnull: [c_char; 20usize],
    pub tform: [c_char; 10usize],
    pub twidth: c_long,
}
impl ::std::clone::Clone for tcolumn {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for tcolumn {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct FITSfile {
    pub filehandle: c_int,
    pub driver: c_int,
    pub open_count: c_int,
    pub filename: *mut c_char,
    pub validcode: c_int,
    pub only_one: c_int,
    pub filesize: LONGLONG,
    pub logfilesize: LONGLONG,
    pub lasthdu: c_int,
    pub bytepos: LONGLONG,
    pub io_pos: LONGLONG,
    pub curbuf: c_int,
    pub curhdu: c_int,
    pub hdutype: c_int,
    pub writemode: c_int,
    pub maxhdu: c_int,
    pub MAXHDU: c_int,
    pub headstart: *mut LONGLONG,
    pub headend: LONGLONG,
    pub ENDpos: LONGLONG,
    pub nextkey: LONGLONG,
    pub datastart: LONGLONG,
    pub imgdim: c_int,
    pub imgnaxis: [LONGLONG; 99usize],
    pub tfield: c_int,
    pub startcol: c_int,
    pub origrows: LONGLONG,
    pub numrows: LONGLONG,
    pub rowlength: LONGLONG,
    pub tableptr: *mut tcolumn,
    pub heapstart: LONGLONG,
    pub heapsize: LONGLONG,
    pub request_compress_type: c_int,
    pub request_tilesize: [c_long; 6usize],
    pub request_quantize_level: c_float,
    pub request_quantize_method: c_int,
    pub request_dither_seed: c_int,
    pub request_lossy_int_compress: c_int,
    pub request_huge_hdu: c_int,
    pub request_hcomp_scale: c_float,
    pub request_hcomp_smooth: c_int,
    pub compress_type: c_int,
    pub tilesize: [c_long; 6usize],
    pub quantize_level: c_float,
    pub quantize_method: c_int,
    pub dither_seed: c_int,
    pub compressimg: c_int,
    pub zcmptype: [c_char; 12usize],
    pub zbitpix: c_int,
    pub zndim: c_int,
    pub znaxis: [c_long; 6usize],
    pub maxtilelen: c_long,
    pub maxelem: c_long,
    pub cn_compressed: c_int,
    pub cn_uncompressed: c_int,
    pub cn_gzip_data: c_int,
    pub cn_zscale: c_int,
    pub cn_zzero: c_int,
    pub cn_zblank: c_int,
    pub zscale: c_double,
    pub zzero: c_double,
    pub cn_bscale: c_double,
    pub cn_bzero: c_double,
    pub cn_actual_bzero: c_double,
    pub zblank: c_int,
    pub rice_blocksize: c_int,
    pub rice_bytepix: c_int,
    pub hcomp_scale: c_float,
    pub hcomp_smooth: c_int,
    pub tilerow: *mut c_int,
    pub tiledatasize: *mut c_long,
    pub tiletype: *mut c_int,
    pub tiledata: *mut *mut c_void,
    pub tilenullarray: *mut *mut c_void,
    pub tileanynull: *mut c_int,
    pub iobuffer: *mut c_char,
    pub bufrecnum: [c_long; 40usize],
    pub dirty: [c_int; 40usize],
    pub ageindex: [c_int; 40usize],
}
impl ::std::clone::Clone for FITSfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for FITSfile {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct fitsfile {
    pub HDUposition: c_int,
    pub Fptr: *mut FITSfile,
}

impl ::std::default::Default for fitsfile {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct iteratorCol {
    pub fptr: *mut fitsfile,
    pub colnum: c_int,
    pub colname: [c_char; 70usize],
    pub datatype: c_int,
    pub iotype: c_int,
    pub array: *mut c_void,
    pub repeat: c_long,
    pub tlmin: c_long,
    pub tlmax: c_long,
    pub tunit: [c_char; 70usize],
    pub tdisp: [c_char; 70usize],
}
impl ::std::clone::Clone for iteratorCol {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for iteratorCol {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct wtbarr {
    pub i: c_int,
    pub m: c_int,
    pub kind: c_int,
    pub extnam: [c_char; 72usize],
    pub extver: c_int,
    pub extlev: c_int,
    pub ttype: [c_char; 72usize],
    pub row: c_long,
    pub ndim: c_int,
    pub dimlen: *mut c_int,
    pub arrayp: *mut *mut c_double,
}
impl ::std::clone::Clone for wtbarr {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for wtbarr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct PixelFilter {
    pub count: c_int,
    pub path: *mut *mut c_char,
    pub tag: *mut *mut c_char,
    pub ifptr: *mut *mut fitsfile,
    pub expression: *mut c_char,
    pub bitpix: c_int,
    pub blank: c_long,
    pub ofptr: *mut fitsfile,
    pub keyword: [c_char; 72usize],
    pub comment: [c_char; 73usize],
}
impl ::std::clone::Clone for PixelFilter {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for PixelFilter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

extern "C" {
    pub fn fits_read_wcstab(
        fptr: *mut fitsfile,
        nwtb: c_int,
        wtb: *mut wtbarr,
        status: *mut c_int,
    ) -> c_int;
    pub fn CFITS2Unit(fptr: *mut fitsfile) -> c_int;
    pub fn CUnit2FITS(unit: c_int) -> *mut fitsfile;
    pub fn fits_get_token(
        ptr: *mut *mut c_char,
        delimiter: *mut c_char,
        token: *mut c_char,
        isanumber: *mut c_int,
    ) -> c_int;
    pub fn fits_get_token2(
        ptr: *mut *mut c_char,
        delimiter: *mut c_char,
        token: *mut *mut c_char,
        isanumber: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_split_names(list: *mut c_char) -> *mut c_char;
    pub fn ffiurl(
        url: *mut c_char,
        urltype: *mut c_char,
        infile: *mut c_char,
        outfile: *mut c_char,
        extspec: *mut c_char,
        rowfilter: *mut c_char,
        binspec: *mut c_char,
        colspec: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffifile(
        url: *mut c_char,
        urltype: *mut c_char,
        infile: *mut c_char,
        outfile: *mut c_char,
        extspec: *mut c_char,
        rowfilter: *mut c_char,
        binspec: *mut c_char,
        colspec: *mut c_char,
        pixfilter: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffifile2(
        url: *mut c_char,
        urltype: *mut c_char,
        infile: *mut c_char,
        outfile: *mut c_char,
        extspec: *mut c_char,
        rowfilter: *mut c_char,
        binspec: *mut c_char,
        colspec: *mut c_char,
        pixfilter: *mut c_char,
        compspec: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffrtnm(url: *mut c_char, rootname: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffexist(infile: *const c_char, exists: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffexts(
        extspec: *mut c_char,
        extnum: *mut c_int,
        extname: *mut c_char,
        extvers: *mut c_int,
        hdutype: *mut c_int,
        colname: *mut c_char,
        rowexpress: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffextn(url: *mut c_char, extension_num: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffurlt(fptr: *mut fitsfile, urlType: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffbins(
        binspec: *mut c_char,
        imagetype: *mut c_int,
        haxis: *mut c_int,
        colname: *mut [c_char; 71usize],
        minin: *mut c_double,
        maxin: *mut c_double,
        binsizein: *mut c_double,
        minname: *mut [c_char; 71usize],
        maxname: *mut [c_char; 71usize],
        binname: *mut [c_char; 71usize],
        weight: *mut c_double,
        wtname: *mut c_char,
        recip: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffbinr(
        binspec: *mut *mut c_char,
        colname: *mut c_char,
        minin: *mut c_double,
        maxin: *mut c_double,
        binsizein: *mut c_double,
        minname: *mut c_char,
        maxname: *mut c_char,
        binname: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_copy_cell2image(
        fptr: *mut fitsfile,
        newptr: *mut fitsfile,
        colname: *mut c_char,
        rownum: c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_copy_image2cell(
        fptr: *mut fitsfile,
        newptr: *mut fitsfile,
        colname: *mut c_char,
        rownum: c_long,
        copykeyflag: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_copy_pixlist2image(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        firstkey: c_int,
        naxis: c_int,
        colnum: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffimport_file(
        filename: *mut c_char,
        contents: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffrwrg(
        rowlist: *mut c_char,
        maxrows: LONGLONG,
        maxranges: c_int,
        numranges: *mut c_int,
        minrow: *mut c_long,
        maxrow: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffrwrgll(
        rowlist: *mut c_char,
        maxrows: LONGLONG,
        maxranges: c_int,
        numranges: *mut c_int,
        minrow: *mut LONGLONG,
        maxrow: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_init_cfitsio() -> c_int;
    pub fn ffomem(
        fptr: *mut *mut fitsfile,
        name: *const c_char,
        mode: c_int,
        buffptr: *mut *mut c_void,
        buffsize: *mut size_t,
        deltasize: size_t,
        mem_realloc: ::std::option::Option<
            unsafe extern "C" fn(p: *mut c_void, newsize: size_t) -> *mut c_void,
        >,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffopen(
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        iomode: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffopentest(
        soname: c_int,
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        iomode: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdopn(
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        iomode: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fftopn(
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        iomode: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffiopn(
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        iomode: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdkopn(
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        iomode: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffreopen(
        openfptr: *mut fitsfile,
        newfptr: *mut *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffinit(fptr: *mut *mut fitsfile, filename: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffdkinit(fptr: *mut *mut fitsfile, filename: *const c_char, status: *mut c_int)
        -> c_int;
    pub fn ffimem(
        fptr: *mut *mut fitsfile,
        buffptr: *mut *mut c_void,
        buffsize: *mut size_t,
        deltasize: size_t,
        mem_realloc: ::std::option::Option<
            unsafe extern "C" fn(p: *mut c_void, newsize: size_t) -> *mut c_void,
        >,
        status: *mut c_int,
    ) -> c_int;
    pub fn fftplt(
        fptr: *mut *mut fitsfile,
        filename: *const c_char,
        tempname: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffflus(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffflsh(fptr: *mut fitsfile, clearbuf: c_int, status: *mut c_int) -> c_int;
    pub fn ffclos(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffdelt(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffflnm(fptr: *mut fitsfile, filename: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffflmd(fptr: *mut fitsfile, filemode: *mut c_int, status: *mut c_int) -> c_int;
    pub fn fits_delete_iraf_file(filename: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffvers(version: *mut c_float) -> c_float;
    pub fn ffupch(string: *mut c_char);
    pub fn ffgerr(status: c_int, errtext: *mut c_char);
    pub fn ffpmsg(err_message: *const c_char);
    pub fn ffpmrk();
    pub fn ffgmsg(err_message: *mut c_char) -> c_int;
    pub fn ffcmsg();
    pub fn ffcmrk();
    pub fn ffrprt(stream: *mut FILE, status: c_int);
    pub fn ffcmps(
        templt: *mut c_char,
        colname: *mut c_char,
        casesen: c_int,
        match_: *mut c_int,
        exact: *mut c_int,
    );
    pub fn fftkey(keyword: *const c_char, status: *mut c_int) -> c_int;
    pub fn fftrec(card: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffnchk(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffkeyn(
        keyroot: *const c_char,
        value: c_int,
        keyname: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffnkey(
        value: c_int,
        keyroot: *const c_char,
        keyname: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkcl(card: *mut c_char) -> c_int;
    pub fn ffdtyp(cval: *const c_char, dtype: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffinttyp(
        cval: *mut c_char,
        datatype: *mut c_int,
        negative: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpsvc(
        card: *mut c_char,
        value: *mut c_char,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgknm(
        card: *mut c_char,
        name: *mut c_char,
        length: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgthd(
        tmplt: *mut c_char,
        card: *mut c_char,
        hdtype: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkky(
        keyname: *const c_char,
        keyval: *mut c_char,
        comm: *const c_char,
        card: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_translate_keyword(
        inrec: *mut c_char,
        outrec: *mut c_char,
        patterns: *mut [*mut c_char; 2usize],
        npat: c_int,
        n_value: c_int,
        n_offset: c_int,
        n_range: c_int,
        pat_num: *mut c_int,
        i: *mut c_int,
        j: *mut c_int,
        m: *mut c_int,
        n: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_translate_keywords(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        firstkey: c_int,
        patterns: *mut [*mut c_char; 2usize],
        npat: c_int,
        n_value: c_int,
        n_offset: c_int,
        n_range: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffasfm(
        tform: *mut c_char,
        datacode: *mut c_int,
        width: *mut c_long,
        decim: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffbnfm(
        tform: *mut c_char,
        datacode: *mut c_int,
        repeat: *mut c_long,
        width: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffbnfmll(
        tform: *mut c_char,
        datacode: *mut c_int,
        repeat: *mut LONGLONG,
        width: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgabc(
        tfields: c_int,
        tform: *mut *mut c_char,
        space: c_int,
        rowlen: *mut c_long,
        tbcol: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_section_range(
        ptr: *mut *mut c_char,
        secmin: *mut c_long,
        secmax: *mut c_long,
        incre: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmbyt(
        fptr: *mut fitsfile,
        bytpos: LONGLONG,
        ignore_err: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpky(
        fptr: *mut fitsfile,
        datatype: c_int,
        keyname: *const c_char,
        value: *mut c_void,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffprec(fptr: *mut fitsfile, card: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffpcom(fptr: *mut fitsfile, comm: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffpunt(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        unit: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphis(fptr: *mut fitsfile, history: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffpdat(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffverifydate(year: c_int, month: c_int, day: c_int, status: *mut c_int) -> c_int;
    pub fn ffgstm(timestr: *mut c_char, timeref: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffgsdt(
        day: *mut c_int,
        month: *mut c_int,
        year: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdt2s(
        year: c_int,
        month: c_int,
        day: c_int,
        datestr: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fftm2s(
        year: c_int,
        month: c_int,
        day: c_int,
        hour: c_int,
        minute: c_int,
        second: c_double,
        decimals: c_int,
        datestr: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffs2dt(
        datestr: *mut c_char,
        year: *mut c_int,
        month: *mut c_int,
        day: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffs2tm(
        datestr: *mut c_char,
        year: *mut c_int,
        month: *mut c_int,
        day: *mut c_int,
        hour: *mut c_int,
        minute: *mut c_int,
        second: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyu(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkys(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkls(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffplsw(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffpkyl(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: LONGLONG,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyf(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkye(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyg(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkym(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkfc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkfm(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkyt(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        intval: c_long,
        frac: c_double,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffptdm(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffptdmll(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkns(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut *mut c_char,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpknl(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut c_int,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpknj(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut c_long,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpknjj(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut LONGLONG,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpknf(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut c_float,
        decim: c_int,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkne(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut c_float,
        decim: c_int,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpkng(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut c_double,
        decim: c_int,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpknd(
        fptr: *mut fitsfile,
        keyroot: *const c_char,
        nstart: c_int,
        nkey: c_int,
        value: *mut c_double,
        decim: c_int,
        comm: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcpky(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        incol: c_int,
        outcol: c_int,
        rootname: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphps(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphpsll(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphpr(
        fptr: *mut fitsfile,
        simple: c_int,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        pcount: LONGLONG,
        gcount: LONGLONG,
        extend: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphprll(
        fptr: *mut fitsfile,
        simple: c_int,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut LONGLONG,
        pcount: LONGLONG,
        gcount: LONGLONG,
        extend: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphtb(
        fptr: *mut fitsfile,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        tfields: c_int,
        ttype: *mut *mut c_char,
        tbcol: *mut c_long,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphbn(
        fptr: *mut fitsfile,
        naxis2: LONGLONG,
        tfields: c_int,
        ttype: *mut *mut c_char,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *const c_char,
        pcount: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffphext(
        fptr: *mut fitsfile,
        xtension: *const c_char,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        pcount: LONGLONG,
        gcount: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpktp(fptr: *mut fitsfile, filename: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffghsp(
        fptr: *mut fitsfile,
        nexist: *mut c_int,
        nmore: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghps(
        fptr: *mut fitsfile,
        nexist: *mut c_int,
        position: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmaky(fptr: *mut fitsfile, nrec: c_int, status: *mut c_int) -> c_int;
    pub fn ffmrky(fptr: *mut fitsfile, nrec: c_int, status: *mut c_int) -> c_int;
    pub fn ffgnxk(
        fptr: *mut fitsfile,
        inclist: *mut *mut c_char,
        ninc: c_int,
        exclist: *mut *mut c_char,
        nexc: c_int,
        card: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgrec(fptr: *mut fitsfile, nrec: c_int, card: *mut c_char, status: *mut c_int)
        -> c_int;
    pub fn ffgcrd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        card: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgstr(
        fptr: *mut fitsfile,
        string: *const c_char,
        card: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgunt(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        unit: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkyn(
        fptr: *mut fitsfile,
        nkey: c_int,
        keyname: *mut c_char,
        keyval: *mut c_char,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkey(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        keyval: *mut c_char,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgky(
        fptr: *mut fitsfile,
        datatype: c_int,
        keyname: *const c_char,
        value: *mut c_void,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkys(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_char,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkls(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut *mut c_char,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fffree(value: *mut c_void, status: *mut c_int) -> c_int;
    pub fn fffkls(value: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffgkyl(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_int,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkyj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_long,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkyjj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut LONGLONG,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkye(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkyd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkyc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkym(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkyt(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        ivalue: *mut c_long,
        dvalue: *mut c_double,
        comm: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtdm(
        fptr: *mut fitsfile,
        colnum: c_int,
        maxdim: c_int,
        naxis: *mut c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtdmll(
        fptr: *mut fitsfile,
        colnum: c_int,
        maxdim: c_int,
        naxis: *mut c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdtdm(
        fptr: *mut fitsfile,
        tdimstr: *mut c_char,
        colnum: c_int,
        maxdim: c_int,
        naxis: *mut c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdtdmll(
        fptr: *mut fitsfile,
        tdimstr: *mut c_char,
        colnum: c_int,
        maxdim: c_int,
        naxis: *mut c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkns(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        nstart: c_int,
        nmax: c_int,
        value: *mut *mut c_char,
        nfound: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgknl(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        nstart: c_int,
        nmax: c_int,
        value: *mut c_int,
        nfound: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgknj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        nstart: c_int,
        nmax: c_int,
        value: *mut c_long,
        nfound: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgknjj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        nstart: c_int,
        nmax: c_int,
        value: *mut LONGLONG,
        nfound: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgkne(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        nstart: c_int,
        nmax: c_int,
        value: *mut c_float,
        nfound: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgknd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        nstart: c_int,
        nmax: c_int,
        value: *mut c_double,
        nfound: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffh2st(fptr: *mut fitsfile, header: *mut *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffhdr2str(
        fptr: *mut fitsfile,
        exclude_comm: c_int,
        exclist: *mut *mut c_char,
        nexc: c_int,
        header: *mut *mut c_char,
        nkeys: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcnvthdr2str(
        fptr: *mut fitsfile,
        exclude_comm: c_int,
        exclist: *mut *mut c_char,
        nexc: c_int,
        header: *mut *mut c_char,
        nkeys: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghpr(
        fptr: *mut fitsfile,
        maxdim: c_int,
        simple: *mut c_int,
        bitpix: *mut c_int,
        naxis: *mut c_int,
        naxes: *mut c_long,
        pcount: *mut c_long,
        gcount: *mut c_long,
        extend: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghprll(
        fptr: *mut fitsfile,
        maxdim: c_int,
        simple: *mut c_int,
        bitpix: *mut c_int,
        naxis: *mut c_int,
        naxes: *mut LONGLONG,
        pcount: *mut c_long,
        gcount: *mut c_long,
        extend: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghtb(
        fptr: *mut fitsfile,
        maxfield: c_int,
        naxis1: *mut c_long,
        naxis2: *mut c_long,
        tfields: *mut c_int,
        ttype: *mut *mut c_char,
        tbcol: *mut c_long,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghtbll(
        fptr: *mut fitsfile,
        maxfield: c_int,
        naxis1: *mut LONGLONG,
        naxis2: *mut LONGLONG,
        tfields: *mut c_int,
        ttype: *mut *mut c_char,
        tbcol: *mut LONGLONG,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghbn(
        fptr: *mut fitsfile,
        maxfield: c_int,
        naxis2: *mut c_long,
        tfields: *mut c_int,
        ttype: *mut *mut c_char,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *mut c_char,
        pcount: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghbnll(
        fptr: *mut fitsfile,
        maxfield: c_int,
        naxis2: *mut LONGLONG,
        tfields: *mut c_int,
        ttype: *mut *mut c_char,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *mut c_char,
        pcount: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffuky(
        fptr: *mut fitsfile,
        datatype: c_int,
        keyname: *const c_char,
        value: *mut c_void,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffucrd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        card: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyu(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukys(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukls(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyl(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: LONGLONG,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyf(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukye(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyg(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukyc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukym(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukfc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffukfm(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmrec(
        fptr: *mut fitsfile,
        nkey: c_int,
        card: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmcrd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        card: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmnam(
        fptr: *mut fitsfile,
        oldname: *const c_char,
        newname: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmcom(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyu(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkys(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkls(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyl(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: LONGLONG,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyf(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkye(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyg(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkyc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkym(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkfc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmkfm(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffirec(
        fptr: *mut fitsfile,
        nkey: c_int,
        card: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikey(fptr: *mut fitsfile, card: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffikyu(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikys(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikls(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *const c_char,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikyl(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikyj(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: LONGLONG,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikyf(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikye(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikyg(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikyd(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikyc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikym(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikfc(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_float,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffikfm(
        fptr: *mut fitsfile,
        keyname: *const c_char,
        value: *mut c_double,
        decim: c_int,
        comm: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdkey(fptr: *mut fitsfile, keyname: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffdstr(fptr: *mut fitsfile, string: *const c_char, status: *mut c_int) -> c_int;
    pub fn ffdrec(fptr: *mut fitsfile, keypos: c_int, status: *mut c_int) -> c_int;
    pub fn ffghdn(fptr: *mut fitsfile, chdunum: *mut c_int) -> c_int;
    pub fn ffghdt(fptr: *mut fitsfile, exttype: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffghad(
        fptr: *mut fitsfile,
        headstart: *mut c_long,
        datastart: *mut c_long,
        dataend: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghadll(
        fptr: *mut fitsfile,
        headstart: *mut LONGLONG,
        datastart: *mut LONGLONG,
        dataend: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffghof(
        fptr: *mut fitsfile,
        headstart: *mut off_t,
        datastart: *mut off_t,
        dataend: *mut off_t,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgipr(
        fptr: *mut fitsfile,
        maxaxis: c_int,
        imgtype: *mut c_int,
        naxis: *mut c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgiprll(
        fptr: *mut fitsfile,
        maxaxis: c_int,
        imgtype: *mut c_int,
        naxis: *mut c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgidt(fptr: *mut fitsfile, imgtype: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffgiet(fptr: *mut fitsfile, imgtype: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffgidm(fptr: *mut fitsfile, naxis: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffgisz(
        fptr: *mut fitsfile,
        nlen: c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgiszll(
        fptr: *mut fitsfile,
        nlen: c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmahd(
        fptr: *mut fitsfile,
        hdunum: c_int,
        exttype: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmrhd(
        fptr: *mut fitsfile,
        hdumov: c_int,
        exttype: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmnhd(
        fptr: *mut fitsfile,
        exttype: c_int,
        hduname: *mut c_char,
        hduvers: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffthdu(fptr: *mut fitsfile, nhdu: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffcrhd(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffcrim(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcrimll(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcrtb(
        fptr: *mut fitsfile,
        tbltype: c_int,
        naxis2: LONGLONG,
        tfields: c_int,
        ttype: *mut *mut c_char,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffiimg(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffiimgll(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffitab(
        fptr: *mut fitsfile,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        tfields: c_int,
        ttype: *mut *mut c_char,
        tbcol: *mut c_long,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *const c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffibin(
        fptr: *mut fitsfile,
        naxis2: LONGLONG,
        tfields: c_int,
        ttype: *mut *mut c_char,
        tform: *mut *mut c_char,
        tunit: *mut *mut c_char,
        extname: *const c_char,
        pcount: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffrsim(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffrsimll(
        fptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdhdu(fptr: *mut fitsfile, hdutype: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffcopy(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        morekeys: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcpfl(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        prev: c_int,
        cur: c_int,
        follow: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcphd(infptr: *mut fitsfile, outfptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffcpdt(infptr: *mut fitsfile, outfptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffchfl(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffcdfl(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffwrhdu(fptr: *mut fitsfile, outstream: *mut FILE, status: *mut c_int) -> c_int;
    pub fn ffrdef(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffhdef(fptr: *mut fitsfile, morekeys: c_int, status: *mut c_int) -> c_int;
    pub fn ffpthp(fptr: *mut fitsfile, theap: c_long, status: *mut c_int) -> c_int;
    pub fn ffcsum(
        fptr: *mut fitsfile,
        nrec: c_long,
        sum: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffesum(sum: c_ulong, complm: c_int, ascii: *mut c_char);
    pub fn ffdsum(ascii: *mut c_char, complm: c_int, sum: *mut c_ulong) -> c_ulong;
    pub fn ffpcks(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffupck(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffvcks(
        fptr: *mut fitsfile,
        datastatus: *mut c_int,
        hdustatus: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcks(
        fptr: *mut fitsfile,
        datasum: *mut c_ulong,
        hdusum: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpscl(
        fptr: *mut fitsfile,
        scale: c_double,
        zero: c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpnul(fptr: *mut fitsfile, nulvalue: LONGLONG, status: *mut c_int) -> c_int;
    pub fn fftscl(
        fptr: *mut fitsfile,
        colnum: c_int,
        scale: c_double,
        zero: c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn fftnul(
        fptr: *mut fitsfile,
        colnum: c_int,
        nulvalue: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffsnul(
        fptr: *mut fitsfile,
        colnum: c_int,
        nulstring: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcno(
        fptr: *mut fitsfile,
        casesen: c_int,
        templt: *mut c_char,
        colnum: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcnn(
        fptr: *mut fitsfile,
        casesen: c_int,
        templt: *mut c_char,
        colname: *mut c_char,
        colnum: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtcl(
        fptr: *mut fitsfile,
        colnum: c_int,
        typecode: *mut c_int,
        repeat: *mut c_long,
        width: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtclll(
        fptr: *mut fitsfile,
        colnum: c_int,
        typecode: *mut c_int,
        repeat: *mut LONGLONG,
        width: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffeqty(
        fptr: *mut fitsfile,
        colnum: c_int,
        typecode: *mut c_int,
        repeat: *mut c_long,
        width: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffeqtyll(
        fptr: *mut fitsfile,
        colnum: c_int,
        typecode: *mut c_int,
        repeat: *mut LONGLONG,
        width: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgncl(fptr: *mut fitsfile, ncols: *mut c_int, status: *mut c_int) -> c_int;
    pub fn ffgnrw(fptr: *mut fitsfile, nrows: *mut c_long, status: *mut c_int) -> c_int;
    pub fn ffgnrwll(fptr: *mut fitsfile, nrows: *mut LONGLONG, status: *mut c_int) -> c_int;
    pub fn ffgacl(
        fptr: *mut fitsfile,
        colnum: c_int,
        ttype: *mut c_char,
        tbcol: *mut c_long,
        tunit: *mut c_char,
        tform: *mut c_char,
        tscal: *mut c_double,
        tzero: *mut c_double,
        tnull: *mut c_char,
        tdisp: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgbcl(
        fptr: *mut fitsfile,
        colnum: c_int,
        ttype: *mut c_char,
        tunit: *mut c_char,
        dtype: *mut c_char,
        repeat: *mut c_long,
        tscal: *mut c_double,
        tzero: *mut c_double,
        tnull: *mut c_long,
        tdisp: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgbclll(
        fptr: *mut fitsfile,
        colnum: c_int,
        ttype: *mut c_char,
        tunit: *mut c_char,
        dtype: *mut c_char,
        repeat: *mut LONGLONG,
        tscal: *mut c_double,
        tzero: *mut c_double,
        tnull: *mut LONGLONG,
        tdisp: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgrsz(fptr: *mut fitsfile, nrows: *mut c_long, status: *mut c_int) -> c_int;
    pub fn ffgcdw(
        fptr: *mut fitsfile,
        colnum: c_int,
        width: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpxv(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut c_long,
        nelem: LONGLONG,
        nulval: *mut c_void,
        array: *mut c_void,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpxvll(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut LONGLONG,
        nelem: LONGLONG,
        nulval: *mut c_void,
        array: *mut c_void,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpxf(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut c_long,
        nelem: LONGLONG,
        array: *mut c_void,
        nullarray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpxfll(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        nullarray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsv(
        fptr: *mut fitsfile,
        datatype: c_int,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: *mut c_void,
        array: *mut c_void,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpv(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: *mut c_void,
        array: *mut c_void,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpf(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        nullarray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_uchar,
        array: *mut c_uchar,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvsb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_char,
        array: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvui(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_ushort,
        array: *mut c_ushort,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvi(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_short,
        array: *mut c_short,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvuj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_ulong,
        array: *mut c_ulong,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_long,
        array: *mut c_long,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvjj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: LONGLONG,
        array: *mut LONGLONG,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvuk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_uint,
        array: *mut c_uint,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_int,
        array: *mut c_int,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpve(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_float,
        array: *mut c_float,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpvd(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_double,
        array: *mut c_double,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uchar,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfsb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfui(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ushort,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfi(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_short,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfuj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ulong,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_long,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfjj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut LONGLONG,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfuk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uint,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_int,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfe(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgpfd(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2db(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_uchar,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_uchar,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2dsb(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_char,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2dui(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_ushort,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_ushort,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2di(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_short,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_short,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2duj(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_ulong,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_ulong,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2dj(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_long,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2djj(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: LONGLONG,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut LONGLONG,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2duk(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_uint,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_uint,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2dk(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_int,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_int,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2de(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_float,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_float,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg2dd(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_double,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_double,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3db(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_uchar,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_uchar,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3dsb(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_char,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3dui(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_ushort,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_ushort,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3di(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_short,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_short,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3duj(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_ulong,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_ulong,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3dj(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_long,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3djj(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: LONGLONG,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut LONGLONG,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3duk(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_uint,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_uint,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3dk(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_int,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_int,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3de(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_float,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_float,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffg3dd(
        fptr: *mut fitsfile,
        group: c_long,
        nulval: c_double,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_double,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvb(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_uchar,
        array: *mut c_uchar,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvsb(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_char,
        array: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvui(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_ushort,
        array: *mut c_ushort,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvi(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_short,
        array: *mut c_short,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvuj(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_ulong,
        array: *mut c_ulong,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvj(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_long,
        array: *mut c_long,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvjj(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: LONGLONG,
        array: *mut LONGLONG,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvuk(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_uint,
        array: *mut c_uint,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvk(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_int,
        array: *mut c_int,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsve(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_float,
        array: *mut c_float,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsvd(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        nulval: c_double,
        array: *mut c_double,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfb(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_uchar,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfsb(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_char,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfui(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_ushort,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfi(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_short,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfuj(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_ulong,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfj(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_long,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfjj(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut LONGLONG,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfuk(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_uint,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfk(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_int,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfe(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_float,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgsfd(
        fptr: *mut fitsfile,
        colnum: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        blc: *mut c_long,
        trc: *mut c_long,
        inc: *mut c_long,
        array: *mut c_double,
        flagval: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpsb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpui(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpi(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpuj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpjj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpuk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpe(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffggpd(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcv(
        fptr: *mut fitsfile,
        datatype: c_int,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: *mut c_void,
        array: *mut c_void,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcf(
        fptr: *mut fitsfile,
        datatype: c_int,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        nullarray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvs(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: *mut c_char,
        array: *mut *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcl(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvl(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_char,
        array: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_uchar,
        array: *mut c_uchar,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvsb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_char,
        array: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvui(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_ushort,
        array: *mut c_ushort,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvi(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_short,
        array: *mut c_short,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvuj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_ulong,
        array: *mut c_ulong,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_long,
        array: *mut c_long,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvjj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: LONGLONG,
        array: *mut LONGLONG,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvuk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_uint,
        array: *mut c_uint,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_int,
        array: *mut c_int,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcve(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_float,
        array: *mut c_float,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvd(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_double,
        array: *mut c_double,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvc(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_float,
        array: *mut c_float,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcvm(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        nulval: c_double,
        array: *mut c_double,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcx(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstbit: LONGLONG,
        nbits: LONGLONG,
        larray: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcxui(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        firstbit: c_long,
        nbits: c_int,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcxuk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        firstbit: c_long,
        nbits: c_int,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfs(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut *mut c_char,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfl(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uchar,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfsb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfui(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ushort,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfi(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_short,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfuj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ulong,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_long,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfjj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut LONGLONG,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfuk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uint,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_int,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfe(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfd(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfc(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgcfm(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        nularray: *mut c_char,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgdes(
        fptr: *mut fitsfile,
        colnum: c_int,
        rownum: LONGLONG,
        length: *mut c_long,
        heapaddr: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgdesll(
        fptr: *mut fitsfile,
        colnum: c_int,
        rownum: LONGLONG,
        length: *mut LONGLONG,
        heapaddr: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgdess(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        length: *mut c_long,
        heapaddr: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgdessll(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        length: *mut LONGLONG,
        heapaddr: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpdes(
        fptr: *mut fitsfile,
        colnum: c_int,
        rownum: LONGLONG,
        length: LONGLONG,
        heapaddr: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn fftheap(
        fptr: *mut fitsfile,
        heapsize: *mut LONGLONG,
        unused: *mut LONGLONG,
        overlap: *mut LONGLONG,
        valid: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcmph(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn ffgtbb(
        fptr: *mut fitsfile,
        firstrow: LONGLONG,
        firstchar: LONGLONG,
        nchars: LONGLONG,
        values: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgextn(
        fptr: *mut fitsfile,
        offset: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpextn(
        fptr: *mut fitsfile,
        offset: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppx(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut c_long,
        nelem: LONGLONG,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppxll(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppxn(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut c_long,
        nelem: LONGLONG,
        array: *mut c_void,
        nulval: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppxnll(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstpix: *mut LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        nulval: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppr(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprsb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprui(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppri(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppruj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppruk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppre(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprd(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprjj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppru(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpprn(
        fptr: *mut fitsfile,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppn(
        fptr: *mut fitsfile,
        datatype: c_int,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        nulval: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uchar,
        nulval: c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnsb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        nulval: c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnui(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ushort,
        nulval: c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppni(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_short,
        nulval: c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_long,
        nulval: c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnuj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ulong,
        nulval: c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnuk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uint,
        nulval: c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_int,
        nulval: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppne(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        nulval: c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnd(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        nulval: c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffppnjj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut LONGLONG,
        nulval: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2db(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2dsb(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2dui(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2di(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2duj(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2dj(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2duk(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2dk(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2de(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2dd(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp2djj(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3db(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3dsb(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3dui(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3di(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3duj(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3dj(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3duk(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3dk(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3de(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3dd(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffp3djj(
        fptr: *mut fitsfile,
        group: c_long,
        ncols: LONGLONG,
        nrows: LONGLONG,
        naxis1: LONGLONG,
        naxis2: LONGLONG,
        naxis3: LONGLONG,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpss(
        fptr: *mut fitsfile,
        datatype: c_int,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssb(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpsssb(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssui(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssi(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssuj(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssj(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssuk(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssk(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpsse(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssd(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpssjj(
        fptr: *mut fitsfile,
        group: c_long,
        naxis: c_long,
        naxes: *mut c_long,
        fpixel: *mut c_long,
        lpixel: *mut c_long,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpsb(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpui(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpi(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpuj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpuk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpk(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpe(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpd(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpgpjj(
        fptr: *mut fitsfile,
        group: c_long,
        firstelem: c_long,
        nelem: c_long,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_iter_set_by_name(
        col: *mut iteratorCol,
        fptr: *mut fitsfile,
        colname: *mut c_char,
        datatype: c_int,
        iotype: c_int,
    ) -> c_int;
    pub fn fits_iter_set_by_num(
        col: *mut iteratorCol,
        fptr: *mut fitsfile,
        colnum: c_int,
        datatype: c_int,
        iotype: c_int,
    ) -> c_int;
    pub fn fits_iter_set_file(col: *mut iteratorCol, fptr: *mut fitsfile) -> c_int;
    pub fn fits_iter_set_colname(col: *mut iteratorCol, colname: *mut c_char) -> c_int;
    pub fn fits_iter_set_colnum(col: *mut iteratorCol, colnum: c_int) -> c_int;
    pub fn fits_iter_set_datatype(col: *mut iteratorCol, datatype: c_int) -> c_int;
    pub fn fits_iter_set_iotype(col: *mut iteratorCol, iotype: c_int) -> c_int;
    pub fn fits_iter_get_file(col: *mut iteratorCol) -> *mut fitsfile;
    pub fn fits_iter_get_colname(col: *mut iteratorCol) -> *mut c_char;
    pub fn fits_iter_get_colnum(col: *mut iteratorCol) -> c_int;
    pub fn fits_iter_get_datatype(col: *mut iteratorCol) -> c_int;
    pub fn fits_iter_get_iotype(col: *mut iteratorCol) -> c_int;
    pub fn fits_iter_get_array(col: *mut iteratorCol) -> *mut c_void;
    pub fn fits_iter_get_tlmin(col: *mut iteratorCol) -> c_long;
    pub fn fits_iter_get_tlmax(col: *mut iteratorCol) -> c_long;
    pub fn fits_iter_get_repeat(col: *mut iteratorCol) -> c_long;
    pub fn fits_iter_get_tunit(col: *mut iteratorCol) -> *mut c_char;
    pub fn fits_iter_get_tdisp(col: *mut iteratorCol) -> *mut c_char;
    pub fn ffiter(
        ncols: c_int,
        data: *mut iteratorCol,
        offset: c_long,
        nPerLoop: c_long,
        workFn: ::std::option::Option<
            unsafe extern "C" fn(
                totaln: c_long,
                offset: c_long,
                firstn: c_long,
                nvalues: c_long,
                narrays: c_int,
                data: *mut iteratorCol,
                userPointer: *mut c_void,
            ) -> c_int,
        >,
        userPointer: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcl(
        fptr: *mut fitsfile,
        datatype: c_int,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcls(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcll(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclsb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclui(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcli(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcluj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcluk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcle(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcld(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclc(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclm(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclu(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffprwu(
        fptr: *mut fitsfile,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcljj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpclx(
        fptr: *mut fitsfile,
        colnum: c_int,
        frow: LONGLONG,
        fbit: c_long,
        nbit: c_long,
        larray: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcn(
        fptr: *mut fitsfile,
        datatype: c_int,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_void,
        nulval: *mut c_void,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcns(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut *mut c_char,
        nulvalue: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnl(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        nulvalue: c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uchar,
        nulvalue: c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnsb(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_char,
        nulvalue: c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnui(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ushort,
        nulvalue: c_ushort,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcni(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_short,
        nulvalue: c_short,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnuj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_ulong,
        nulvalue: c_ulong,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_long,
        nulvalue: c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnuk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_uint,
        nulvalue: c_uint,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnk(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_int,
        nulvalue: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcne(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_float,
        nulvalue: c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnd(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut c_double,
        nulvalue: c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffpcnjj(
        fptr: *mut fitsfile,
        colnum: c_int,
        firstrow: LONGLONG,
        firstelem: LONGLONG,
        nelem: LONGLONG,
        array: *mut LONGLONG,
        nulvalue: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffptbb(
        fptr: *mut fitsfile,
        firstrow: LONGLONG,
        firstchar: LONGLONG,
        nchars: LONGLONG,
        values: *mut c_uchar,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffirow(
        fptr: *mut fitsfile,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdrow(
        fptr: *mut fitsfile,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdrrg(fptr: *mut fitsfile, ranges: *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffdrws(
        fptr: *mut fitsfile,
        rownum: *mut c_long,
        nrows: c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdrwsll(
        fptr: *mut fitsfile,
        rownum: *mut LONGLONG,
        nrows: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn fficol(
        fptr: *mut fitsfile,
        numcol: c_int,
        ttype: *mut c_char,
        tform: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fficls(
        fptr: *mut fitsfile,
        firstcol: c_int,
        ncols: c_int,
        ttype: *mut *mut c_char,
        tform: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffmvec(
        fptr: *mut fitsfile,
        colnum: c_int,
        newveclen: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffdcol(fptr: *mut fitsfile, numcol: c_int, status: *mut c_int) -> c_int;
    pub fn ffcpcl(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        incol: c_int,
        outcol: c_int,
        create_col: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcprw(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        firstrow: LONGLONG,
        nrows: LONGLONG,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgics(
        fptr: *mut fitsfile,
        xrval: *mut c_double,
        yrval: *mut c_double,
        xrpix: *mut c_double,
        yrpix: *mut c_double,
        xinc: *mut c_double,
        yinc: *mut c_double,
        rot: *mut c_double,
        type_: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgicsa(
        fptr: *mut fitsfile,
        version: c_char,
        xrval: *mut c_double,
        yrval: *mut c_double,
        xrpix: *mut c_double,
        yrpix: *mut c_double,
        xinc: *mut c_double,
        yinc: *mut c_double,
        rot: *mut c_double,
        type_: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtcs(
        fptr: *mut fitsfile,
        xcol: c_int,
        ycol: c_int,
        xrval: *mut c_double,
        yrval: *mut c_double,
        xrpix: *mut c_double,
        yrpix: *mut c_double,
        xinc: *mut c_double,
        yinc: *mut c_double,
        rot: *mut c_double,
        type_: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffwldp(
        xpix: c_double,
        ypix: c_double,
        xref: c_double,
        yref: c_double,
        xrefpix: c_double,
        yrefpix: c_double,
        xinc: c_double,
        yinc: c_double,
        rot: c_double,
        type_: *mut c_char,
        xpos: *mut c_double,
        ypos: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffxypx(
        xpos: c_double,
        ypos: c_double,
        xref: c_double,
        yref: c_double,
        xrefpix: c_double,
        yrefpix: c_double,
        xinc: c_double,
        yinc: c_double,
        rot: c_double,
        type_: *mut c_char,
        xpix: *mut c_double,
        ypix: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgiwcs(fptr: *mut fitsfile, header: *mut *mut c_char, status: *mut c_int) -> c_int;
    pub fn ffgtwcs(
        fptr: *mut fitsfile,
        xcol: c_int,
        ycol: c_int,
        header: *mut *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fftexp(
        fptr: *mut fitsfile,
        expr: *mut c_char,
        maxdim: c_int,
        datatype: *mut c_int,
        nelem: *mut c_long,
        naxis: *mut c_int,
        naxes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fffrow(
        infptr: *mut fitsfile,
        expr: *mut c_char,
        firstrow: c_long,
        nrows: c_long,
        n_good_rows: *mut c_long,
        row_status: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffffrw(
        fptr: *mut fitsfile,
        expr: *mut c_char,
        rownum: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fffrwc(
        fptr: *mut fitsfile,
        expr: *mut c_char,
        timeCol: *mut c_char,
        parCol: *mut c_char,
        valCol: *mut c_char,
        ntimes: c_long,
        times: *mut c_double,
        time_status: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffsrow(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        expr: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcrow(
        fptr: *mut fitsfile,
        datatype: c_int,
        expr: *mut c_char,
        firstrow: c_long,
        nelements: c_long,
        nulval: *mut c_void,
        array: *mut c_void,
        anynul: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcalc_rng(
        infptr: *mut fitsfile,
        expr: *mut c_char,
        outfptr: *mut fitsfile,
        parName: *mut c_char,
        parInfo: *mut c_char,
        nRngs: c_int,
        start: *mut c_long,
        end: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffcalc(
        infptr: *mut fitsfile,
        expr: *mut c_char,
        outfptr: *mut fitsfile,
        parName: *mut c_char,
        parInfo: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffhist(
        fptr: *mut *mut fitsfile,
        outfile: *mut c_char,
        imagetype: c_int,
        naxis: c_int,
        colname: *mut [c_char; 71usize],
        minin: *mut c_double,
        maxin: *mut c_double,
        binsizein: *mut c_double,
        minname: *mut [c_char; 71usize],
        maxname: *mut [c_char; 71usize],
        binname: *mut [c_char; 71usize],
        weightin: c_double,
        wtcol: *mut c_char,
        recip: c_int,
        rowselect: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffhist2(
        fptr: *mut *mut fitsfile,
        outfile: *mut c_char,
        imagetype: c_int,
        naxis: c_int,
        colname: *mut [c_char; 71usize],
        minin: *mut c_double,
        maxin: *mut c_double,
        binsizein: *mut c_double,
        minname: *mut [c_char; 71usize],
        maxname: *mut [c_char; 71usize],
        binname: *mut [c_char; 71usize],
        weightin: c_double,
        wtcol: *mut c_char,
        recip: c_int,
        rowselect: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_select_image_section(
        fptr: *mut *mut fitsfile,
        outfile: *mut c_char,
        imagesection: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_copy_image_section(
        infptr: *mut fitsfile,
        outfile: *mut fitsfile,
        imagesection: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_calc_binning(
        fptr: *mut fitsfile,
        naxis: c_int,
        colname: *mut [c_char; 71usize],
        minin: *mut c_double,
        maxin: *mut c_double,
        binsizein: *mut c_double,
        minname: *mut [c_char; 71usize],
        maxname: *mut [c_char; 71usize],
        binname: *mut [c_char; 71usize],
        colnum: *mut c_int,
        haxes: *mut c_long,
        amin: *mut c_float,
        amax: *mut c_float,
        binsize: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_write_keys_histo(
        fptr: *mut fitsfile,
        histptr: *mut fitsfile,
        naxis: c_int,
        colnum: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_rebin_wcs(
        fptr: *mut fitsfile,
        naxis: c_int,
        amin: *mut c_float,
        binsize: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_make_hist(
        fptr: *mut fitsfile,
        histptr: *mut fitsfile,
        bitpix: c_int,
        naxis: c_int,
        naxes: *mut c_long,
        colnum: *mut c_int,
        amin: *mut c_float,
        amax: *mut c_float,
        binsize: *mut c_float,
        weight: c_float,
        wtcolnum: c_int,
        recip: c_int,
        selectrow: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_pixel_filter(filter: *mut PixelFilter, status: *mut c_int) -> c_int;
    pub fn ffgtcr(
        fptr: *mut fitsfile,
        grpname: *mut c_char,
        grouptype: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtis(
        fptr: *mut fitsfile,
        grpname: *mut c_char,
        grouptype: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtch(gfptr: *mut fitsfile, grouptype: c_int, status: *mut c_int) -> c_int;
    pub fn ffgtrm(gfptr: *mut fitsfile, rmopt: c_int, status: *mut c_int) -> c_int;
    pub fn ffgtcp(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        cpopt: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtmg(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        mgopt: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtcm(gfptr: *mut fitsfile, cmopt: c_int, status: *mut c_int) -> c_int;
    pub fn ffgtvf(gfptr: *mut fitsfile, firstfailed: *mut c_long, status: *mut c_int) -> c_int;
    pub fn ffgtop(
        mfptr: *mut fitsfile,
        group: c_int,
        gfptr: *mut *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtam(
        gfptr: *mut fitsfile,
        mfptr: *mut fitsfile,
        hdupos: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgtnm(gfptr: *mut fitsfile, nmembers: *mut c_long, status: *mut c_int) -> c_int;
    pub fn ffgmng(mfptr: *mut fitsfile, nmembers: *mut c_long, status: *mut c_int) -> c_int;
    pub fn ffgmop(
        gfptr: *mut fitsfile,
        member: c_long,
        mfptr: *mut *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgmcp(
        gfptr: *mut fitsfile,
        mfptr: *mut fitsfile,
        member: c_long,
        cpopt: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgmtf(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        member: c_long,
        tfopt: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn ffgmrm(fptr: *mut fitsfile, member: c_long, rmopt: c_int, status: *mut c_int) -> c_int;
    pub fn fits_execute_template(
        ff: *mut fitsfile,
        ngp_template: *mut c_char,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_img_stats_short(
        array: *mut c_short,
        nx: c_long,
        ny: c_long,
        nullcheck: c_int,
        nullvalue: c_short,
        ngoodpix: *mut c_long,
        minvalue: *mut c_short,
        maxvalue: *mut c_short,
        mean: *mut c_double,
        sigma: *mut c_double,
        noise1: *mut c_double,
        noise2: *mut c_double,
        noise3: *mut c_double,
        noise5: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_img_stats_int(
        array: *mut c_int,
        nx: c_long,
        ny: c_long,
        nullcheck: c_int,
        nullvalue: c_int,
        ngoodpix: *mut c_long,
        minvalue: *mut c_int,
        maxvalue: *mut c_int,
        mean: *mut c_double,
        sigma: *mut c_double,
        noise1: *mut c_double,
        noise2: *mut c_double,
        noise3: *mut c_double,
        noise5: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_img_stats_float(
        array: *mut c_float,
        nx: c_long,
        ny: c_long,
        nullcheck: c_int,
        nullvalue: c_float,
        ngoodpix: *mut c_long,
        minvalue: *mut c_float,
        maxvalue: *mut c_float,
        mean: *mut c_double,
        sigma: *mut c_double,
        noise1: *mut c_double,
        noise2: *mut c_double,
        noise3: *mut c_double,
        noise5: *mut c_double,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_set_compression_type(
        fptr: *mut fitsfile,
        ctype: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_set_tile_dim(
        fptr: *mut fitsfile,
        ndim: c_int,
        dims: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_set_noise_bits(fptr: *mut fitsfile, noisebits: c_int, status: *mut c_int) -> c_int;
    pub fn fits_set_quantize_level(
        fptr: *mut fitsfile,
        qlevel: c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_set_hcomp_scale(fptr: *mut fitsfile, scale: c_float, status: *mut c_int) -> c_int;
    pub fn fits_set_hcomp_smooth(fptr: *mut fitsfile, smooth: c_int, status: *mut c_int) -> c_int;
    pub fn fits_set_quantize_method(
        fptr: *mut fitsfile,
        method: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_set_quantize_dither(
        fptr: *mut fitsfile,
        dither: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_set_dither_seed(fptr: *mut fitsfile, seed: c_int, status: *mut c_int) -> c_int;
    pub fn fits_set_dither_offset(fptr: *mut fitsfile, offset: c_int, status: *mut c_int) -> c_int;
    pub fn fits_set_lossy_int(fptr: *mut fitsfile, lossy_int: c_int, status: *mut c_int) -> c_int;
    pub fn fits_set_huge_hdu(fptr: *mut fitsfile, huge: c_int, status: *mut c_int) -> c_int;
    pub fn fits_set_compression_pref(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_compression_type(
        fptr: *mut fitsfile,
        ctype: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_tile_dim(
        fptr: *mut fitsfile,
        ndim: c_int,
        dims: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_quantize_level(
        fptr: *mut fitsfile,
        qlevel: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_noise_bits(
        fptr: *mut fitsfile,
        noisebits: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_hcomp_scale(
        fptr: *mut fitsfile,
        scale: *mut c_float,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_hcomp_smooth(
        fptr: *mut fitsfile,
        smooth: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_get_dither_seed(fptr: *mut fitsfile, seed: *mut c_int, status: *mut c_int)
        -> c_int;
    pub fn fits_img_compress(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_comp_img(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        compress_type: c_int,
        tilesize: *mut c_long,
        parm1: c_int,
        parm2: c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_is_compressed_image(fptr: *mut fitsfile, status: *mut c_int) -> c_int;
    pub fn fits_is_reentrant() -> c_int;
    pub fn fits_decomp_img(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_img_decompress_header(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_img_decompress(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_hcompress(
        a: *mut c_int,
        nx: c_int,
        ny: c_int,
        scale: c_int,
        output: *mut c_char,
        nbytes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_hcompress64(
        a: *mut LONGLONG,
        nx: c_int,
        ny: c_int,
        scale: c_int,
        output: *mut c_char,
        nbytes: *mut c_long,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_hdecompress(
        input: *mut c_uchar,
        smooth: c_int,
        a: *mut c_int,
        nx: *mut c_int,
        ny: *mut c_int,
        scale: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_hdecompress64(
        input: *mut c_uchar,
        smooth: c_int,
        a: *mut LONGLONG,
        nx: *mut c_int,
        ny: *mut c_int,
        scale: *mut c_int,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_compress_table(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
    pub fn fits_uncompress_table(
        infptr: *mut fitsfile,
        outfptr: *mut fitsfile,
        status: *mut c_int,
    ) -> c_int;
}

#[cfg(test)]
mod test {
    extern crate tempdir;

    use super::*;
    use libc::c_char;
    use std::ffi;
    use std::ptr;

    #[test]
    fn raw_opening_an_existing_file() {
        let mut fptr = ptr::null_mut();
        let mut status = -1;
        let c_filename = ffi::CString::new("../testdata/full_example.fits").unwrap();

        unsafe {
            ffopen(
                &mut fptr as *mut *mut fitsfile,
                c_filename.as_ptr(),
                0,
                &mut status,
            );
            ffclos(fptr, &mut status);
        }

        assert_eq!(status, 0);
    }

    #[test]
    fn raw_creating_a_new_file() {
        // Set up the test filename
        let tdir = tempdir::TempDir::new("rust-fitsio-").unwrap();
        let filename = tdir.path().join("test.fits");
        assert!(!filename.exists());

        let mut fptr = ptr::null_mut();
        let mut status = 0;
        let c_filename = ffi::CString::new(filename.to_str().unwrap()).unwrap();

        unsafe {
            ffinit(
                &mut fptr as *mut *mut fitsfile,
                c_filename.as_ptr(),
                &mut status,
            );
        }

        assert!(filename.exists());
    }

    #[test]
    fn getting_current_hdu_number() {
        let mut fptr = ptr::null_mut();
        let mut status = -1;
        let c_filename = ffi::CString::new("../testdata/full_example.fits").unwrap();
        let mut hdu_num = -1;

        unsafe {
            ffopen(
                &mut fptr as *mut *mut fitsfile,
                c_filename.as_ptr(),
                0,
                &mut status,
            );
            ffghdn(fptr, &mut hdu_num);
            ffclos(fptr, &mut status);
        }

        assert_eq!(hdu_num, 1);
    }

    #[test]
    fn changing_hdu_by_absolute_number() {
        let mut fptr = ptr::null_mut();
        let mut status = -1;
        let c_filename = ffi::CString::new("../testdata/full_example.fits").unwrap();

        let mut hdu_type = 0;
        let mut hdu_num = 0;

        unsafe {
            ffopen(
                &mut fptr as *mut *mut fitsfile,
                c_filename.as_ptr(),
                0,
                &mut status,
            );
            ffmahd(fptr, 2, &mut hdu_type, &mut status);
            ffghdn(fptr, &mut hdu_num);
            ffclos(fptr, &mut status);
        }

        assert_eq!(hdu_num, 2);
    }

    #[test]
    fn reading_header_key_value() {
        let mut fptr = ptr::null_mut();
        let mut status = -1;
        let c_filename = ffi::CString::new("../testdata/full_example.fits").unwrap();

        let mut long_value = 0;
        let mut float_value = 0.0;
        let mut double_value = 0.0;
        let keyname = ffi::CString::new("INTTEST").unwrap();
        let double_keyname = ffi::CString::new("DBLTEST").unwrap();
        let mut comment: Vec<c_char> = vec![0; 73];
        unsafe {
            ffopen(
                &mut fptr as *mut *mut fitsfile,
                c_filename.as_ptr(),
                0,
                &mut status,
            );
            ffgkyj(
                fptr,
                keyname.as_ptr(),
                &mut long_value,
                ptr::null_mut(),
                &mut status,
            );
            ffgkye(
                fptr,
                keyname.as_ptr(),
                &mut float_value,
                ptr::null_mut(),
                &mut status,
            );

            // Double version is different
            ffgkyd(
                fptr,
                double_keyname.as_ptr(),
                &mut double_value,
                comment.as_mut_ptr(),
                &mut status,
            );
            ffclos(fptr, &mut status);
        }

        assert_eq!(long_value, 42);
        assert_eq!(float_value, 42.0);
        assert_eq!(double_value, 3. / 32.);

        // TODO Hacky way of getting a string out. This should be simplified.
        let comment: Vec<u8> = comment
            .iter()
            .map(|&x| x as u8)
            .filter(|&x| x != 0)
            .collect();
        let comment = String::from_utf8(comment).unwrap();
        assert_eq!(comment, "Double value");
    }

    // #[test]
    // fn api_usage() {
    // use fitsio::FitsFile;
    //
    // let mut f = FitsFile::open("../testdata/full_example.fits");
    // let mut primary_hdu = f.primary_hdu();
    // let header = primary_hdu.header();
    // let exposure_time: f32 = header["exposure"];
    // }
    //
}
